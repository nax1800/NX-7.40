#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ControlRig

#include "Basic.hpp"

#include "AnimationCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "Engine_structs.hpp"
#include "MovieSceneTracks_structs.hpp"
#include "MovieScene_structs.hpp"


namespace SDK
{

// Enum ControlRig.ERigExecutionType
// NumValues: 0x0003
enum class ERigExecutionType : uint8
{
	Runtime                                  = 0,
	Editing                                  = 1,
	Max                                      = 2,
};

// Enum ControlRig.EControlRigOpCode
// NumValues: 0x0005
enum class EControlRigOpCode : uint8
{
	Done                                     = 0,
	Copy                                     = 1,
	Exec                                     = 2,
	Invalid                                  = 3,
	EControlRigOpCode_MAX                    = 4,
};

// Enum ControlRig.ETransformGetterType
// NumValues: 0x0003
enum class ETransformGetterType : uint8
{
	Initial                                  = 0,
	Current                                  = 1,
	Max                                      = 2,
};

// Enum ControlRig.ETransformSpaceMode
// NumValues: 0x0005
enum class ETransformSpaceMode : uint8
{
	LocalSpace                               = 0,
	GlobalSpace                              = 1,
	BaseSpace                                = 2,
	BaseJoint                                = 3,
	Max                                      = 4,
};

// Enum ControlRig.EUnitExecutionType
// NumValues: 0x0004
enum class EUnitExecutionType : uint8
{
	Always                                   = 0,
	InEditingTime                            = 1,
	Disable                                  = 2,
	Max                                      = 3,
};

// Enum ControlRig.EAimMode
// NumValues: 0x0003
enum class EAimMode : uint8
{
	AimAtTarget                              = 0,
	OrientToTarget                           = 1,
	MAX                                      = 2,
};

// Enum ControlRig.EApplyTransformMode
// NumValues: 0x0003
enum class EApplyTransformMode : uint8
{
	Override                                 = 0,
	Additive                                 = 1,
	Max                                      = 2,
};

// Enum ControlRig.EControlRigState
// NumValues: 0x0004
enum class EControlRigState : uint8
{
	Init                                     = 0,
	Update                                   = 1,
	Invalid                                  = 2,
	EControlRigState_MAX                     = 3,
};

// ScriptStruct ControlRig.RigHierarchyRef
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FRigHierarchyRef final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseBaseHierarchy;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigHierarchyRef) == 0x000008, "Wrong alignment on FRigHierarchyRef");
static_assert(sizeof(FRigHierarchyRef) == 0x000018, "Wrong size on FRigHierarchyRef");
static_assert(offsetof(FRigHierarchyRef, bUseBaseHierarchy) == 0x000008, "Member 'FRigHierarchyRef::bUseBaseHierarchy' has a wrong offset!");
static_assert(offsetof(FRigHierarchyRef, Name) == 0x00000C, "Member 'FRigHierarchyRef::Name' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FRigUnit
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RigUnitName;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RigUnitStructName;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnitExecutionType                            ExecutionType;                                     // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit) == 0x000008, "Wrong alignment on FRigUnit");
static_assert(sizeof(FRigUnit) == 0x000020, "Wrong size on FRigUnit");
static_assert(offsetof(FRigUnit, RigUnitName) == 0x000008, "Member 'FRigUnit::RigUnitName' has a wrong offset!");
static_assert(offsetof(FRigUnit, RigUnitStructName) == 0x000010, "Member 'FRigUnit::RigUnitStructName' has a wrong offset!");
static_assert(offsetof(FRigUnit, ExecutionType) == 0x000018, "Member 'FRigUnit::ExecutionType' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_FABRIK
// 0x0048 (0x0068 - 0x0020)
struct FRigUnit_FABRIK final : public FRigUnit
{
public:
	struct FRigHierarchyRef                       HierarchyRef;                                      // 0x0020(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   StartJoint;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndJoint;                                          // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Precision;                                         // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIterations;                                     // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_FABRIK) == 0x000008, "Wrong alignment on FRigUnit_FABRIK");
static_assert(sizeof(FRigUnit_FABRIK) == 0x000068, "Wrong size on FRigUnit_FABRIK");
static_assert(offsetof(FRigUnit_FABRIK, HierarchyRef) == 0x000020, "Member 'FRigUnit_FABRIK::HierarchyRef' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, StartJoint) == 0x000038, "Member 'FRigUnit_FABRIK::StartJoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, EndJoint) == 0x000040, "Member 'FRigUnit_FABRIK::EndJoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, Precision) == 0x000048, "Member 'FRigUnit_FABRIK::Precision' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, MaxIterations) == 0x00004C, "Member 'FRigUnit_FABRIK::MaxIterations' has a wrong offset!");

// ScriptStruct ControlRig.ConstraintNodeData
// 0x00B0 (0x00B0 - 0x0000)
struct FConstraintNodeData final
{
public:
	struct FTransform                             RelativeParent;                                    // 0x0000(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FConstraintOffset                      ConstraintOffset;                                  // 0x0030(0x0060)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   LinkedNode;                                        // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransformConstraint>           Constraints;                                       // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConstraintNodeData) == 0x000010, "Wrong alignment on FConstraintNodeData");
static_assert(sizeof(FConstraintNodeData) == 0x0000B0, "Wrong size on FConstraintNodeData");
static_assert(offsetof(FConstraintNodeData, RelativeParent) == 0x000000, "Member 'FConstraintNodeData::RelativeParent' has a wrong offset!");
static_assert(offsetof(FConstraintNodeData, ConstraintOffset) == 0x000030, "Member 'FConstraintNodeData::ConstraintOffset' has a wrong offset!");
static_assert(offsetof(FConstraintNodeData, LinkedNode) == 0x000090, "Member 'FConstraintNodeData::LinkedNode' has a wrong offset!");
static_assert(offsetof(FConstraintNodeData, Constraints) == 0x000098, "Member 'FConstraintNodeData::Constraints' has a wrong offset!");

// ScriptStruct ControlRig.AnimationHierarchy
// 0x0010 (0x0088 - 0x0078)
struct FAnimationHierarchy final : public FNodeHierarchyWithUserData
{
public:
	TArray<struct FConstraintNodeData>            UserData;                                          // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationHierarchy) == 0x000008, "Wrong alignment on FAnimationHierarchy");
static_assert(sizeof(FAnimationHierarchy) == 0x000088, "Wrong size on FAnimationHierarchy");
static_assert(offsetof(FAnimationHierarchy, UserData) == 0x000078, "Member 'FAnimationHierarchy::UserData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_UnaryQuaternionOp
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_UnaryQuaternionOp : public FRigUnit
{
public:
	struct FQuat                                  Argument;                                          // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_UnaryQuaternionOp) == 0x000010, "Wrong alignment on FRigUnit_UnaryQuaternionOp");
static_assert(sizeof(FRigUnit_UnaryQuaternionOp) == 0x000040, "Wrong size on FRigUnit_UnaryQuaternionOp");
static_assert(offsetof(FRigUnit_UnaryQuaternionOp, Argument) == 0x000020, "Member 'FRigUnit_UnaryQuaternionOp::Argument' has a wrong offset!");
static_assert(offsetof(FRigUnit_UnaryQuaternionOp, Result) == 0x000030, "Member 'FRigUnit_UnaryQuaternionOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_InverseQuaterion
// 0x0000 (0x0040 - 0x0040)
struct FRigUnit_InverseQuaterion final : public FRigUnit_UnaryQuaternionOp
{
};
static_assert(alignof(FRigUnit_InverseQuaterion) == 0x000010, "Wrong alignment on FRigUnit_InverseQuaterion");
static_assert(sizeof(FRigUnit_InverseQuaterion) == 0x000040, "Wrong size on FRigUnit_InverseQuaterion");

// ScriptStruct ControlRig.AnimNode_ControlRigBase
// 0x0018 (0x0028 - 0x0010)
struct FAnimNode_ControlRigBase : public FAnimNode_Base
{
public:
	TArray<class FName>                           RigHierarchyItemNameMapping;                       // 0x0010(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UNodeMappingContainer>   NodeMappingContainer;                              // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FAnimNode_ControlRigBase) == 0x000008, "Wrong alignment on FAnimNode_ControlRigBase");
static_assert(sizeof(FAnimNode_ControlRigBase) == 0x000028, "Wrong size on FAnimNode_ControlRigBase");
static_assert(offsetof(FAnimNode_ControlRigBase, RigHierarchyItemNameMapping) == 0x000010, "Member 'FAnimNode_ControlRigBase::RigHierarchyItemNameMapping' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRigBase, NodeMappingContainer) == 0x000020, "Member 'FAnimNode_ControlRigBase::NodeMappingContainer' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BinaryVectorOp
// 0x0028 (0x0048 - 0x0020)
struct FRigUnit_BinaryVectorOp : public FRigUnit
{
public:
	struct FVector                                Argument0;                                         // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Argument1;                                         // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_BinaryVectorOp) == 0x000008, "Wrong alignment on FRigUnit_BinaryVectorOp");
static_assert(sizeof(FRigUnit_BinaryVectorOp) == 0x000048, "Wrong size on FRigUnit_BinaryVectorOp");
static_assert(offsetof(FRigUnit_BinaryVectorOp, Argument0) == 0x000020, "Member 'FRigUnit_BinaryVectorOp::Argument0' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryVectorOp, Argument1) == 0x00002C, "Member 'FRigUnit_BinaryVectorOp::Argument1' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryVectorOp, Result) == 0x000038, "Member 'FRigUnit_BinaryVectorOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Subtract_VectorVector
// 0x0000 (0x0048 - 0x0048)
struct FRigUnit_Subtract_VectorVector final : public FRigUnit_BinaryVectorOp
{
};
static_assert(alignof(FRigUnit_Subtract_VectorVector) == 0x000008, "Wrong alignment on FRigUnit_Subtract_VectorVector");
static_assert(sizeof(FRigUnit_Subtract_VectorVector) == 0x000048, "Wrong size on FRigUnit_Subtract_VectorVector");

// ScriptStruct ControlRig.RigUnit_BinaryFloatOp
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_BinaryFloatOp : public FRigUnit
{
public:
	float                                         Argument0;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Argument1;                                         // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_BinaryFloatOp) == 0x000008, "Wrong alignment on FRigUnit_BinaryFloatOp");
static_assert(sizeof(FRigUnit_BinaryFloatOp) == 0x000030, "Wrong size on FRigUnit_BinaryFloatOp");
static_assert(offsetof(FRigUnit_BinaryFloatOp, Argument0) == 0x000020, "Member 'FRigUnit_BinaryFloatOp::Argument0' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryFloatOp, Argument1) == 0x000024, "Member 'FRigUnit_BinaryFloatOp::Argument1' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryFloatOp, Result) == 0x000028, "Member 'FRigUnit_BinaryFloatOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigBindingTemplate
// 0x0000 (0x00B0 - 0x00B0)
struct FControlRigBindingTemplate final : public FMovieSceneSpawnSectionTemplate
{
};
static_assert(alignof(FControlRigBindingTemplate) == 0x000008, "Wrong alignment on FControlRigBindingTemplate");
static_assert(sizeof(FControlRigBindingTemplate) == 0x0000B0, "Wrong size on FControlRigBindingTemplate");

// ScriptStruct ControlRig.AnimNode_ControlRig
// 0x0020 (0x0048 - 0x0028)
struct FAnimNode_ControlRig final : public FAnimNode_ControlRigBase
{
public:
	struct FPoseLink                              Source;                                            // 0x0028(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class UControlRig>                ControlRigClass;                                   // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UControlRig*                            ControlRig;                                        // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAnimNode_ControlRig) == 0x000008, "Wrong alignment on FAnimNode_ControlRig");
static_assert(sizeof(FAnimNode_ControlRig) == 0x000048, "Wrong size on FAnimNode_ControlRig");
static_assert(offsetof(FAnimNode_ControlRig, Source) == 0x000028, "Member 'FAnimNode_ControlRig::Source' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRig, ControlRigClass) == 0x000038, "Member 'FAnimNode_ControlRig::ControlRigClass' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRig, ControlRig) == 0x000040, "Member 'FAnimNode_ControlRig::ControlRig' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Distance_VectorVector
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_Distance_VectorVector final : public FRigUnit
{
public:
	struct FVector                                Argument0;                                         // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Argument1;                                         // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_Distance_VectorVector) == 0x000008, "Wrong alignment on FRigUnit_Distance_VectorVector");
static_assert(sizeof(FRigUnit_Distance_VectorVector) == 0x000040, "Wrong size on FRigUnit_Distance_VectorVector");
static_assert(offsetof(FRigUnit_Distance_VectorVector, Argument0) == 0x000020, "Member 'FRigUnit_Distance_VectorVector::Argument0' has a wrong offset!");
static_assert(offsetof(FRigUnit_Distance_VectorVector, Argument1) == 0x00002C, "Member 'FRigUnit_Distance_VectorVector::Argument1' has a wrong offset!");
static_assert(offsetof(FRigUnit_Distance_VectorVector, Result) == 0x000038, "Member 'FRigUnit_Distance_VectorVector::Result' has a wrong offset!");

// ScriptStruct ControlRig.MovieSceneControlRigInstanceData
// 0x00D0 (0x00D8 - 0x0008)
struct FMovieSceneControlRigInstanceData final : public FMovieSceneSequenceInstanceData
{
public:
	bool                                          bAdditive;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyBoneFilter;                                  // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputBlendPose                        BoneFilter;                                        // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                Weight;                                            // 0x0020(0x00A0)(NativeAccessSpecifierPublic)
	struct FMovieSceneEvaluationOperand           Operand;                                           // 0x00C0(0x0014)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovieSceneControlRigInstanceData) == 0x000008, "Wrong alignment on FMovieSceneControlRigInstanceData");
static_assert(sizeof(FMovieSceneControlRigInstanceData) == 0x0000D8, "Wrong size on FMovieSceneControlRigInstanceData");
static_assert(offsetof(FMovieSceneControlRigInstanceData, bAdditive) == 0x000008, "Member 'FMovieSceneControlRigInstanceData::bAdditive' has a wrong offset!");
static_assert(offsetof(FMovieSceneControlRigInstanceData, bApplyBoneFilter) == 0x000009, "Member 'FMovieSceneControlRigInstanceData::bApplyBoneFilter' has a wrong offset!");
static_assert(offsetof(FMovieSceneControlRigInstanceData, BoneFilter) == 0x000010, "Member 'FMovieSceneControlRigInstanceData::BoneFilter' has a wrong offset!");
static_assert(offsetof(FMovieSceneControlRigInstanceData, Weight) == 0x000020, "Member 'FMovieSceneControlRigInstanceData::Weight' has a wrong offset!");
static_assert(offsetof(FMovieSceneControlRigInstanceData, Operand) == 0x0000C0, "Member 'FMovieSceneControlRigInstanceData::Operand' has a wrong offset!");

// ScriptStruct ControlRig.AnimNode_ControlRig_ExternalSource
// 0x0008 (0x0030 - 0x0028)
struct FAnimNode_ControlRig_ExternalSource final : public FAnimNode_ControlRigBase
{
public:
	TWeakObjectPtr<class UControlRig>             ControlRig;                                        // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAnimNode_ControlRig_ExternalSource) == 0x000008, "Wrong alignment on FAnimNode_ControlRig_ExternalSource");
static_assert(sizeof(FAnimNode_ControlRig_ExternalSource) == 0x000030, "Wrong size on FAnimNode_ControlRig_ExternalSource");
static_assert(offsetof(FAnimNode_ControlRig_ExternalSource, ControlRig) == 0x000028, "Member 'FAnimNode_ControlRig_ExternalSource::ControlRig' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigOperator
// 0x0028 (0x0028 - 0x0000)
struct FControlRigOperator final
{
public:
	EControlRigOpCode                             OpCode;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PropertyPath1;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PropertyPath2;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlRigOperator) == 0x000008, "Wrong alignment on FControlRigOperator");
static_assert(sizeof(FControlRigOperator) == 0x000028, "Wrong size on FControlRigOperator");
static_assert(offsetof(FControlRigOperator, OpCode) == 0x000000, "Member 'FControlRigOperator::OpCode' has a wrong offset!");
static_assert(offsetof(FControlRigOperator, PropertyPath1) == 0x000008, "Member 'FControlRigOperator::PropertyPath1' has a wrong offset!");
static_assert(offsetof(FControlRigOperator, PropertyPath2) == 0x000018, "Member 'FControlRigOperator::PropertyPath2' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigSequenceObjectReference
// 0x0008 (0x0008 - 0x0000)
struct FControlRigSequenceObjectReference final
{
public:
	TSubclassOf<class UControlRig>                ControlRigClass;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FControlRigSequenceObjectReference) == 0x000008, "Wrong alignment on FControlRigSequenceObjectReference");
static_assert(sizeof(FControlRigSequenceObjectReference) == 0x000008, "Wrong size on FControlRigSequenceObjectReference");
static_assert(offsetof(FControlRigSequenceObjectReference, ControlRigClass) == 0x000000, "Member 'FControlRigSequenceObjectReference::ControlRigClass' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigSequenceObjectReferences
// 0x0010 (0x0010 - 0x0000)
struct FControlRigSequenceObjectReferences final
{
public:
	TArray<struct FControlRigSequenceObjectReference> Array;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlRigSequenceObjectReferences) == 0x000008, "Wrong alignment on FControlRigSequenceObjectReferences");
static_assert(sizeof(FControlRigSequenceObjectReferences) == 0x000010, "Wrong size on FControlRigSequenceObjectReferences");
static_assert(offsetof(FControlRigSequenceObjectReferences, Array) == 0x000000, "Member 'FControlRigSequenceObjectReferences::Array' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigSequenceObjectReferenceMap
// 0x0020 (0x0020 - 0x0000)
struct FControlRigSequenceObjectReferenceMap final
{
public:
	TArray<struct FGuid>                          BindingIds;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FControlRigSequenceObjectReferences> References;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FControlRigSequenceObjectReferenceMap) == 0x000008, "Wrong alignment on FControlRigSequenceObjectReferenceMap");
static_assert(sizeof(FControlRigSequenceObjectReferenceMap) == 0x000020, "Wrong size on FControlRigSequenceObjectReferenceMap");
static_assert(offsetof(FControlRigSequenceObjectReferenceMap, BindingIds) == 0x000000, "Member 'FControlRigSequenceObjectReferenceMap::BindingIds' has a wrong offset!");
static_assert(offsetof(FControlRigSequenceObjectReferenceMap, References) == 0x000010, "Member 'FControlRigSequenceObjectReferenceMap::References' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ToSwingAndTwist
// 0x0040 (0x0060 - 0x0020)
struct FRigUnit_ToSwingAndTwist final : public FRigUnit
{
public:
	struct FQuat                                  Input;                                             // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TwistAxis;                                         // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Swing;                                             // 0x0040(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Twist;                                             // 0x0050(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ToSwingAndTwist) == 0x000010, "Wrong alignment on FRigUnit_ToSwingAndTwist");
static_assert(sizeof(FRigUnit_ToSwingAndTwist) == 0x000060, "Wrong size on FRigUnit_ToSwingAndTwist");
static_assert(offsetof(FRigUnit_ToSwingAndTwist, Input) == 0x000020, "Member 'FRigUnit_ToSwingAndTwist::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ToSwingAndTwist, TwistAxis) == 0x000030, "Member 'FRigUnit_ToSwingAndTwist::TwistAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_ToSwingAndTwist, Swing) == 0x000040, "Member 'FRigUnit_ToSwingAndTwist::Swing' has a wrong offset!");
static_assert(offsetof(FRigUnit_ToSwingAndTwist, Twist) == 0x000050, "Member 'FRigUnit_ToSwingAndTwist::Twist' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Subtract_FloatFloat
// 0x0000 (0x0030 - 0x0030)
struct FRigUnit_Subtract_FloatFloat final : public FRigUnit_BinaryFloatOp
{
};
static_assert(alignof(FRigUnit_Subtract_FloatFloat) == 0x000008, "Wrong alignment on FRigUnit_Subtract_FloatFloat");
static_assert(sizeof(FRigUnit_Subtract_FloatFloat) == 0x000030, "Wrong size on FRigUnit_Subtract_FloatFloat");

// ScriptStruct ControlRig.ControlRigSequencerAnimInstanceProxy
// 0x0170 (0x09C0 - 0x0850)
struct FControlRigSequencerAnimInstanceProxy final : public FAnimSequencerInstanceProxy
{
public:
	uint8                                         Pad_850[0x170];                                    // 0x0850(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlRigSequencerAnimInstanceProxy) == 0x000010, "Wrong alignment on FControlRigSequencerAnimInstanceProxy");
static_assert(sizeof(FControlRigSequencerAnimInstanceProxy) == 0x0009C0, "Wrong size on FControlRigSequencerAnimInstanceProxy");

// ScriptStruct ControlRig.AimTarget
// 0x0050 (0x0050 - 0x0000)
struct FAimTarget final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AlignVector;                                       // 0x0040(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAimTarget) == 0x000010, "Wrong alignment on FAimTarget");
static_assert(sizeof(FAimTarget) == 0x000050, "Wrong size on FAimTarget");
static_assert(offsetof(FAimTarget, Weight) == 0x000000, "Member 'FAimTarget::Weight' has a wrong offset!");
static_assert(offsetof(FAimTarget, Transform) == 0x000010, "Member 'FAimTarget::Transform' has a wrong offset!");
static_assert(offsetof(FAimTarget, AlignVector) == 0x000040, "Member 'FAimTarget::AlignVector' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AimConstraint
// 0x0070 (0x0090 - 0x0020)
struct FRigUnit_AimConstraint final : public FRigUnit
{
public:
	struct FRigHierarchyRef                       HierarchyRef;                                      // 0x0020(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	class FName                                   Joint;                                             // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAimMode                                      AimMode;                                           // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAimMode                                      UpMode;                                            // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimVector;                                         // 0x0044(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                UpVector;                                          // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAimTarget>                     AimTargets;                                        // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FAimTarget>                     UpTargets;                                         // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AimConstraint) == 0x000008, "Wrong alignment on FRigUnit_AimConstraint");
static_assert(sizeof(FRigUnit_AimConstraint) == 0x000090, "Wrong size on FRigUnit_AimConstraint");
static_assert(offsetof(FRigUnit_AimConstraint, HierarchyRef) == 0x000020, "Member 'FRigUnit_AimConstraint::HierarchyRef' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, Joint) == 0x000038, "Member 'FRigUnit_AimConstraint::Joint' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, AimMode) == 0x000040, "Member 'FRigUnit_AimConstraint::AimMode' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, UpMode) == 0x000041, "Member 'FRigUnit_AimConstraint::UpMode' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, AimVector) == 0x000044, "Member 'FRigUnit_AimConstraint::AimVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, UpVector) == 0x000050, "Member 'FRigUnit_AimConstraint::UpVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, AimTargets) == 0x000060, "Member 'FRigUnit_AimConstraint::AimTargets' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, UpTargets) == 0x000070, "Member 'FRigUnit_AimConstraint::UpTargets' has a wrong offset!");

// ScriptStruct ControlRig.RigJoint
// 0x00C0 (0x00C0 - 0x0000)
struct FRigJoint final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentName;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParentIndex;                                       // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InitialTransform;                                  // 0x0020(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             GlobalTransform;                                   // 0x0050(0x0030)(Edit, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             LocalTransform;                                    // 0x0080(0x0030)(Edit, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Dependents;                                        // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigJoint) == 0x000010, "Wrong alignment on FRigJoint");
static_assert(sizeof(FRigJoint) == 0x0000C0, "Wrong size on FRigJoint");
static_assert(offsetof(FRigJoint, Name) == 0x000000, "Member 'FRigJoint::Name' has a wrong offset!");
static_assert(offsetof(FRigJoint, ParentName) == 0x000008, "Member 'FRigJoint::ParentName' has a wrong offset!");
static_assert(offsetof(FRigJoint, ParentIndex) == 0x000010, "Member 'FRigJoint::ParentIndex' has a wrong offset!");
static_assert(offsetof(FRigJoint, InitialTransform) == 0x000020, "Member 'FRigJoint::InitialTransform' has a wrong offset!");
static_assert(offsetof(FRigJoint, GlobalTransform) == 0x000050, "Member 'FRigJoint::GlobalTransform' has a wrong offset!");
static_assert(offsetof(FRigJoint, LocalTransform) == 0x000080, "Member 'FRigJoint::LocalTransform' has a wrong offset!");
static_assert(offsetof(FRigJoint, Dependents) == 0x0000B0, "Member 'FRigJoint::Dependents' has a wrong offset!");

// ScriptStruct ControlRig.RigHierarchy
// 0x0060 (0x0060 - 0x0000)
struct FRigHierarchy final
{
public:
	TArray<struct FRigJoint>                      Joints;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      NameToIndexMapping;                                // 0x0010(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigHierarchy) == 0x000008, "Wrong alignment on FRigHierarchy");
static_assert(sizeof(FRigHierarchy) == 0x000060, "Wrong size on FRigHierarchy");
static_assert(offsetof(FRigHierarchy, Joints) == 0x000000, "Member 'FRigHierarchy::Joints' has a wrong offset!");
static_assert(offsetof(FRigHierarchy, NameToIndexMapping) == 0x000010, "Member 'FRigHierarchy::NameToIndexMapping' has a wrong offset!");

// ScriptStruct ControlRig.RigHierarchyContainer
// 0x00C0 (0x00C0 - 0x0000)
struct FRigHierarchyContainer final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigHierarchy                          BaseHierarchy;                                     // 0x0060(0x0060)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigHierarchyContainer) == 0x000008, "Wrong alignment on FRigHierarchyContainer");
static_assert(sizeof(FRigHierarchyContainer) == 0x0000C0, "Wrong size on FRigHierarchyContainer");
static_assert(offsetof(FRigHierarchyContainer, BaseHierarchy) == 0x000060, "Member 'FRigHierarchyContainer::BaseHierarchy' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertRotationToVector
// 0x0018 (0x0038 - 0x0020)
struct FRigUnit_ConvertRotationToVector final : public FRigUnit
{
public:
	struct FRotator                               Input;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ConvertRotationToVector) == 0x000008, "Wrong alignment on FRigUnit_ConvertRotationToVector");
static_assert(sizeof(FRigUnit_ConvertRotationToVector) == 0x000038, "Wrong size on FRigUnit_ConvertRotationToVector");
static_assert(offsetof(FRigUnit_ConvertRotationToVector, Input) == 0x000020, "Member 'FRigUnit_ConvertRotationToVector::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertRotationToVector, Result) == 0x00002C, "Member 'FRigUnit_ConvertRotationToVector::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MergeHierarchy
// 0x0030 (0x0050 - 0x0020)
struct FRigUnit_MergeHierarchy final : public FRigUnit
{
public:
	struct FRigHierarchyRef                       TargetHierarchy;                                   // 0x0020(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigHierarchyRef                       SourceHierarchy;                                   // 0x0038(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MergeHierarchy) == 0x000008, "Wrong alignment on FRigUnit_MergeHierarchy");
static_assert(sizeof(FRigUnit_MergeHierarchy) == 0x000050, "Wrong size on FRigUnit_MergeHierarchy");
static_assert(offsetof(FRigUnit_MergeHierarchy, TargetHierarchy) == 0x000020, "Member 'FRigUnit_MergeHierarchy::TargetHierarchy' has a wrong offset!");
static_assert(offsetof(FRigUnit_MergeHierarchy, SourceHierarchy) == 0x000038, "Member 'FRigUnit_MergeHierarchy::SourceHierarchy' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ApplyFK
// 0x00A0 (0x00C0 - 0x0020)
struct FRigUnit_ApplyFK final : public FRigUnit
{
public:
	struct FRigHierarchyRef                       HierarchyRef;                                      // 0x0020(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   Joint;                                             // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0040(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransformFilter                       Filter;                                            // 0x0070(0x0009)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EApplyTransformMode                           ApplyTransformMode;                                // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformSpaceMode                           ApplyTransformSpace;                               // 0x007A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B[0x5];                                       // 0x007B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BaseTransform;                                     // 0x0080(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   BaseJoint;                                         // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ApplyFK) == 0x000010, "Wrong alignment on FRigUnit_ApplyFK");
static_assert(sizeof(FRigUnit_ApplyFK) == 0x0000C0, "Wrong size on FRigUnit_ApplyFK");
static_assert(offsetof(FRigUnit_ApplyFK, HierarchyRef) == 0x000020, "Member 'FRigUnit_ApplyFK::HierarchyRef' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, Joint) == 0x000038, "Member 'FRigUnit_ApplyFK::Joint' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, Transform) == 0x000040, "Member 'FRigUnit_ApplyFK::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, Filter) == 0x000070, "Member 'FRigUnit_ApplyFK::Filter' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, ApplyTransformMode) == 0x000079, "Member 'FRigUnit_ApplyFK::ApplyTransformMode' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, ApplyTransformSpace) == 0x00007A, "Member 'FRigUnit_ApplyFK::ApplyTransformSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, BaseTransform) == 0x000080, "Member 'FRigUnit_ApplyFK::BaseTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, BaseJoint) == 0x0000B0, "Member 'FRigUnit_ApplyFK::BaseJoint' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BinaryTransformOp
// 0x0090 (0x00B0 - 0x0020)
struct FRigUnit_BinaryTransformOp : public FRigUnit
{
public:
	struct FTransform                             Argument0;                                         // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Argument1;                                         // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x0080(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BinaryTransformOp) == 0x000010, "Wrong alignment on FRigUnit_BinaryTransformOp");
static_assert(sizeof(FRigUnit_BinaryTransformOp) == 0x0000B0, "Wrong size on FRigUnit_BinaryTransformOp");
static_assert(offsetof(FRigUnit_BinaryTransformOp, Argument0) == 0x000020, "Member 'FRigUnit_BinaryTransformOp::Argument0' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryTransformOp, Argument1) == 0x000050, "Member 'FRigUnit_BinaryTransformOp::Argument1' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryTransformOp, Result) == 0x000080, "Member 'FRigUnit_BinaryTransformOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MultiplyTransform
// 0x0000 (0x00B0 - 0x00B0)
struct FRigUnit_MultiplyTransform final : public FRigUnit_BinaryTransformOp
{
};
static_assert(alignof(FRigUnit_MultiplyTransform) == 0x000010, "Wrong alignment on FRigUnit_MultiplyTransform");
static_assert(sizeof(FRigUnit_MultiplyTransform) == 0x0000B0, "Wrong size on FRigUnit_MultiplyTransform");

// ScriptStruct ControlRig.BlendTarget
// 0x0040 (0x0040 - 0x0000)
struct FBlendTarget final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlendTarget) == 0x000010, "Wrong alignment on FBlendTarget");
static_assert(sizeof(FBlendTarget) == 0x000040, "Wrong size on FBlendTarget");
static_assert(offsetof(FBlendTarget, Transform) == 0x000000, "Member 'FBlendTarget::Transform' has a wrong offset!");
static_assert(offsetof(FBlendTarget, Weight) == 0x000030, "Member 'FBlendTarget::Weight' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BlendTransform
// 0x0070 (0x0090 - 0x0020)
struct FRigUnit_BlendTransform final : public FRigUnit
{
public:
	struct FTransform                             Source;                                            // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBlendTarget>                   Targets;                                           // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x0060(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BlendTransform) == 0x000010, "Wrong alignment on FRigUnit_BlendTransform");
static_assert(sizeof(FRigUnit_BlendTransform) == 0x000090, "Wrong size on FRigUnit_BlendTransform");
static_assert(offsetof(FRigUnit_BlendTransform, Source) == 0x000020, "Member 'FRigUnit_BlendTransform::Source' has a wrong offset!");
static_assert(offsetof(FRigUnit_BlendTransform, Targets) == 0x000050, "Member 'FRigUnit_BlendTransform::Targets' has a wrong offset!");
static_assert(offsetof(FRigUnit_BlendTransform, Result) == 0x000060, "Member 'FRigUnit_BlendTransform::Result' has a wrong offset!");

// ScriptStruct ControlRig.ConstraintTarget
// 0x0040 (0x0040 - 0x0000)
struct FConstraintTarget final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainOffset;                                   // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransformFilter                       Filter;                                            // 0x0035(0x0009)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConstraintTarget) == 0x000010, "Wrong alignment on FConstraintTarget");
static_assert(sizeof(FConstraintTarget) == 0x000040, "Wrong size on FConstraintTarget");
static_assert(offsetof(FConstraintTarget, Transform) == 0x000000, "Member 'FConstraintTarget::Transform' has a wrong offset!");
static_assert(offsetof(FConstraintTarget, Weight) == 0x000030, "Member 'FConstraintTarget::Weight' has a wrong offset!");
static_assert(offsetof(FConstraintTarget, bMaintainOffset) == 0x000034, "Member 'FConstraintTarget::bMaintainOffset' has a wrong offset!");
static_assert(offsetof(FConstraintTarget, Filter) == 0x000035, "Member 'FConstraintTarget::Filter' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Control
// 0x00D0 (0x00F0 - 0x0020)
struct FRigUnit_Control : public FRigUnit
{
public:
	struct FEulerTransform                        Transform;                                         // 0x0020(0x0024)(Edit, BlueprintVisible, Interp, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Base;                                              // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             InitTransform;                                     // 0x0080(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x00B0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransformFilter                       Filter;                                            // 0x00E0(0x0009)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_Control) == 0x000010, "Wrong alignment on FRigUnit_Control");
static_assert(sizeof(FRigUnit_Control) == 0x0000F0, "Wrong size on FRigUnit_Control");
static_assert(offsetof(FRigUnit_Control, Transform) == 0x000020, "Member 'FRigUnit_Control::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_Control, Base) == 0x000050, "Member 'FRigUnit_Control::Base' has a wrong offset!");
static_assert(offsetof(FRigUnit_Control, InitTransform) == 0x000080, "Member 'FRigUnit_Control::InitTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_Control, Result) == 0x0000B0, "Member 'FRigUnit_Control::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_Control, Filter) == 0x0000E0, "Member 'FRigUnit_Control::Filter' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Control_StaticMesh
// 0x0000 (0x00F0 - 0x00F0)
struct FRigUnit_Control_StaticMesh final : public FRigUnit_Control
{
};
static_assert(alignof(FRigUnit_Control_StaticMesh) == 0x000010, "Wrong alignment on FRigUnit_Control_StaticMesh");
static_assert(sizeof(FRigUnit_Control_StaticMesh) == 0x0000F0, "Wrong size on FRigUnit_Control_StaticMesh");

// ScriptStruct ControlRig.RigUnit_Multiply_FloatFloat
// 0x0000 (0x0030 - 0x0030)
struct FRigUnit_Multiply_FloatFloat final : public FRigUnit_BinaryFloatOp
{
};
static_assert(alignof(FRigUnit_Multiply_FloatFloat) == 0x000008, "Wrong alignment on FRigUnit_Multiply_FloatFloat");
static_assert(sizeof(FRigUnit_Multiply_FloatFloat) == 0x000030, "Wrong size on FRigUnit_Multiply_FloatFloat");

// ScriptStruct ControlRig.RigUnit_ConvertQuaternionToVector
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_ConvertQuaternionToVector final : public FRigUnit
{
public:
	struct FQuat                                  Input;                                             // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ConvertQuaternionToVector) == 0x000010, "Wrong alignment on FRigUnit_ConvertQuaternionToVector");
static_assert(sizeof(FRigUnit_ConvertQuaternionToVector) == 0x000040, "Wrong size on FRigUnit_ConvertQuaternionToVector");
static_assert(offsetof(FRigUnit_ConvertQuaternionToVector, Input) == 0x000020, "Member 'FRigUnit_ConvertQuaternionToVector::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertQuaternionToVector, Result) == 0x000030, "Member 'FRigUnit_ConvertQuaternionToVector::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertVectorToQuaternion
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_ConvertVectorToQuaternion final : public FRigUnit
{
public:
	struct FVector                                Input;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ConvertVectorToQuaternion) == 0x000010, "Wrong alignment on FRigUnit_ConvertVectorToQuaternion");
static_assert(sizeof(FRigUnit_ConvertVectorToQuaternion) == 0x000040, "Wrong size on FRigUnit_ConvertVectorToQuaternion");
static_assert(offsetof(FRigUnit_ConvertVectorToQuaternion, Input) == 0x000020, "Member 'FRigUnit_ConvertVectorToQuaternion::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertVectorToQuaternion, Result) == 0x000030, "Member 'FRigUnit_ConvertVectorToQuaternion::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertVectorToRotation
// 0x0018 (0x0038 - 0x0020)
struct FRigUnit_ConvertVectorToRotation final : public FRigUnit
{
public:
	struct FVector                                Input;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Result;                                            // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ConvertVectorToRotation) == 0x000008, "Wrong alignment on FRigUnit_ConvertVectorToRotation");
static_assert(sizeof(FRigUnit_ConvertVectorToRotation) == 0x000038, "Wrong size on FRigUnit_ConvertVectorToRotation");
static_assert(offsetof(FRigUnit_ConvertVectorToRotation, Input) == 0x000020, "Member 'FRigUnit_ConvertVectorToRotation::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertVectorToRotation, Result) == 0x00002C, "Member 'FRigUnit_ConvertVectorToRotation::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertQuaternion
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_ConvertQuaternion final : public FRigUnit
{
public:
	struct FQuat                                  Input;                                             // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Result;                                            // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ConvertQuaternion) == 0x000010, "Wrong alignment on FRigUnit_ConvertQuaternion");
static_assert(sizeof(FRigUnit_ConvertQuaternion) == 0x000040, "Wrong size on FRigUnit_ConvertQuaternion");
static_assert(offsetof(FRigUnit_ConvertQuaternion, Input) == 0x000020, "Member 'FRigUnit_ConvertQuaternion::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertQuaternion, Result) == 0x000030, "Member 'FRigUnit_ConvertQuaternion::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertRotation
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_ConvertRotation final : public FRigUnit
{
public:
	struct FRotator                               Input;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ConvertRotation) == 0x000010, "Wrong alignment on FRigUnit_ConvertRotation");
static_assert(sizeof(FRigUnit_ConvertRotation) == 0x000040, "Wrong size on FRigUnit_ConvertRotation");
static_assert(offsetof(FRigUnit_ConvertRotation, Input) == 0x000020, "Member 'FRigUnit_ConvertRotation::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertRotation, Result) == 0x000030, "Member 'FRigUnit_ConvertRotation::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_QuaternionFromAxisAndAngle
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_QuaternionFromAxisAndAngle final : public FRigUnit
{
public:
	struct FVector                                Axis;                                              // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_QuaternionFromAxisAndAngle) == 0x000010, "Wrong alignment on FRigUnit_QuaternionFromAxisAndAngle");
static_assert(sizeof(FRigUnit_QuaternionFromAxisAndAngle) == 0x000040, "Wrong size on FRigUnit_QuaternionFromAxisAndAngle");
static_assert(offsetof(FRigUnit_QuaternionFromAxisAndAngle, Axis) == 0x000020, "Member 'FRigUnit_QuaternionFromAxisAndAngle::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionFromAxisAndAngle, Angle) == 0x00002C, "Member 'FRigUnit_QuaternionFromAxisAndAngle::Angle' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionFromAxisAndAngle, Result) == 0x000030, "Member 'FRigUnit_QuaternionFromAxisAndAngle::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertEulerTransform
// 0x0060 (0x0080 - 0x0020)
struct FRigUnit_ConvertEulerTransform final : public FRigUnit
{
public:
	struct FEulerTransform                        Input;                                             // 0x0020(0x0024)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Result;                                            // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ConvertEulerTransform) == 0x000010, "Wrong alignment on FRigUnit_ConvertEulerTransform");
static_assert(sizeof(FRigUnit_ConvertEulerTransform) == 0x000080, "Wrong size on FRigUnit_ConvertEulerTransform");
static_assert(offsetof(FRigUnit_ConvertEulerTransform, Input) == 0x000020, "Member 'FRigUnit_ConvertEulerTransform::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertEulerTransform, Result) == 0x000050, "Member 'FRigUnit_ConvertEulerTransform::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertTransform
// 0x0060 (0x0080 - 0x0020)
struct FRigUnit_ConvertTransform final : public FRigUnit
{
public:
	struct FTransform                             Input;                                             // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEulerTransform                        Result;                                            // 0x0050(0x0024)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0xC];                                       // 0x0074(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ConvertTransform) == 0x000010, "Wrong alignment on FRigUnit_ConvertTransform");
static_assert(sizeof(FRigUnit_ConvertTransform) == 0x000080, "Wrong size on FRigUnit_ConvertTransform");
static_assert(offsetof(FRigUnit_ConvertTransform, Input) == 0x000020, "Member 'FRigUnit_ConvertTransform::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertTransform, Result) == 0x000050, "Member 'FRigUnit_ConvertTransform::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Add_VectorVector
// 0x0000 (0x0048 - 0x0048)
struct FRigUnit_Add_VectorVector final : public FRigUnit_BinaryVectorOp
{
};
static_assert(alignof(FRigUnit_Add_VectorVector) == 0x000008, "Wrong alignment on FRigUnit_Add_VectorVector");
static_assert(sizeof(FRigUnit_Add_VectorVector) == 0x000048, "Wrong size on FRigUnit_Add_VectorVector");

// ScriptStruct ControlRig.RigUnit_CreateHierarchy
// 0x0038 (0x0058 - 0x0020)
struct FRigUnit_CreateHierarchy final : public FRigUnit
{
public:
	struct FRigHierarchyRef                       NewHierarchy;                                      // 0x0020(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigHierarchyRef                       SourceHierarchy;                                   // 0x0038(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   Root;                                              // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CreateHierarchy) == 0x000008, "Wrong alignment on FRigUnit_CreateHierarchy");
static_assert(sizeof(FRigUnit_CreateHierarchy) == 0x000058, "Wrong size on FRigUnit_CreateHierarchy");
static_assert(offsetof(FRigUnit_CreateHierarchy, NewHierarchy) == 0x000020, "Member 'FRigUnit_CreateHierarchy::NewHierarchy' has a wrong offset!");
static_assert(offsetof(FRigUnit_CreateHierarchy, SourceHierarchy) == 0x000038, "Member 'FRigUnit_CreateHierarchy::SourceHierarchy' has a wrong offset!");
static_assert(offsetof(FRigUnit_CreateHierarchy, Root) == 0x000050, "Member 'FRigUnit_CreateHierarchy::Root' has a wrong offset!");

// ScriptStruct ControlRig.StructReference
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FStructReference
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStructReference) == 0x000008, "Wrong alignment on FStructReference");
static_assert(sizeof(FStructReference) == 0x000008, "Wrong size on FStructReference");

// ScriptStruct ControlRig.RigUnitReference_Example
// 0x0000 (0x0008 - 0x0008)
struct FRigUnitReference_Example final : public FStructReference
{
};
static_assert(alignof(FRigUnitReference_Example) == 0x000008, "Wrong alignment on FRigUnitReference_Example");
static_assert(sizeof(FRigUnitReference_Example) == 0x000008, "Wrong size on FRigUnitReference_Example");

// ScriptStruct ControlRig.RigUnit_Example
// 0x00B0 (0x00D0 - 0x0020)
struct FRigUnit_Example final : public FRigUnit
{
public:
	class FString                                 TestInputString;                                   // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEulerTransform                        TestInOutTransform;                                // 0x0030(0x0024)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TestInputVector;                                   // 0x0054(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TestInputInteger;                                  // 0x0060(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                TestInputObject;                                   // 0x0068(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TestOutputVector;                                  // 0x0070(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestInputFloat;                                    // 0x007C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 TestInputFloatArray;                               // 0x0080(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     TestInputTransformArray;                           // 0x0090(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FRigHierarchyRef                       HierarchyRef;                                      // 0x00A0(0x0018)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TestOutputFloat;                                   // 0x00B8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnitReference_Example              TestUnitReferenceInput;                            // 0x00C0(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnitReference_Example              TestUnitReferenceOutput;                           // 0x00C8(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_Example) == 0x000008, "Wrong alignment on FRigUnit_Example");
static_assert(sizeof(FRigUnit_Example) == 0x0000D0, "Wrong size on FRigUnit_Example");
static_assert(offsetof(FRigUnit_Example, TestInputString) == 0x000020, "Member 'FRigUnit_Example::TestInputString' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestInOutTransform) == 0x000030, "Member 'FRigUnit_Example::TestInOutTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestInputVector) == 0x000054, "Member 'FRigUnit_Example::TestInputVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestInputInteger) == 0x000060, "Member 'FRigUnit_Example::TestInputInteger' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestInputObject) == 0x000068, "Member 'FRigUnit_Example::TestInputObject' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestOutputVector) == 0x000070, "Member 'FRigUnit_Example::TestOutputVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestInputFloat) == 0x00007C, "Member 'FRigUnit_Example::TestInputFloat' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestInputFloatArray) == 0x000080, "Member 'FRigUnit_Example::TestInputFloatArray' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestInputTransformArray) == 0x000090, "Member 'FRigUnit_Example::TestInputTransformArray' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, HierarchyRef) == 0x0000A0, "Member 'FRigUnit_Example::HierarchyRef' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestOutputFloat) == 0x0000B8, "Member 'FRigUnit_Example::TestOutputFloat' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestUnitReferenceInput) == 0x0000C0, "Member 'FRigUnit_Example::TestUnitReferenceInput' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestUnitReferenceOutput) == 0x0000C8, "Member 'FRigUnit_Example::TestUnitReferenceOutput' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BinaryQuaternionOp
// 0x0030 (0x0050 - 0x0020)
struct FRigUnit_BinaryQuaternionOp : public FRigUnit
{
public:
	struct FQuat                                  Argument0;                                         // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Argument1;                                         // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0040(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BinaryQuaternionOp) == 0x000010, "Wrong alignment on FRigUnit_BinaryQuaternionOp");
static_assert(sizeof(FRigUnit_BinaryQuaternionOp) == 0x000050, "Wrong size on FRigUnit_BinaryQuaternionOp");
static_assert(offsetof(FRigUnit_BinaryQuaternionOp, Argument0) == 0x000020, "Member 'FRigUnit_BinaryQuaternionOp::Argument0' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryQuaternionOp, Argument1) == 0x000030, "Member 'FRigUnit_BinaryQuaternionOp::Argument1' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryQuaternionOp, Result) == 0x000040, "Member 'FRigUnit_BinaryQuaternionOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Clamp_Float
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_Clamp_Float final : public FRigUnit
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_Clamp_Float) == 0x000008, "Wrong alignment on FRigUnit_Clamp_Float");
static_assert(sizeof(FRigUnit_Clamp_Float) == 0x000030, "Wrong size on FRigUnit_Clamp_Float");
static_assert(offsetof(FRigUnit_Clamp_Float, Value) == 0x000020, "Member 'FRigUnit_Clamp_Float::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_Clamp_Float, Min) == 0x000024, "Member 'FRigUnit_Clamp_Float::Min' has a wrong offset!");
static_assert(offsetof(FRigUnit_Clamp_Float, Max) == 0x000028, "Member 'FRigUnit_Clamp_Float::Max' has a wrong offset!");
static_assert(offsetof(FRigUnit_Clamp_Float, Result) == 0x00002C, "Member 'FRigUnit_Clamp_Float::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Divide_FloatFloat
// 0x0000 (0x0030 - 0x0030)
struct FRigUnit_Divide_FloatFloat final : public FRigUnit_BinaryFloatOp
{
};
static_assert(alignof(FRigUnit_Divide_FloatFloat) == 0x000008, "Wrong alignment on FRigUnit_Divide_FloatFloat");
static_assert(sizeof(FRigUnit_Divide_FloatFloat) == 0x000030, "Wrong size on FRigUnit_Divide_FloatFloat");

// ScriptStruct ControlRig.RigUnit_Add_FloatFloat
// 0x0000 (0x0030 - 0x0030)
struct FRigUnit_Add_FloatFloat final : public FRigUnit_BinaryFloatOp
{
};
static_assert(alignof(FRigUnit_Add_FloatFloat) == 0x000008, "Wrong alignment on FRigUnit_Add_FloatFloat");
static_assert(sizeof(FRigUnit_Add_FloatFloat) == 0x000030, "Wrong size on FRigUnit_Add_FloatFloat");

// ScriptStruct ControlRig.RigUnit_GetJointTransform
// 0x00A0 (0x00C0 - 0x0020)
struct FRigUnit_GetJointTransform final : public FRigUnit
{
public:
	struct FRigHierarchyRef                       HierarchyRef;                                      // 0x0020(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   Joint;                                             // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformGetterType                          Type;                                              // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformSpaceMode                           TransformSpace;                                    // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0xE];                                       // 0x0042(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BaseTransform;                                     // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   BaseJoint;                                         // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Output;                                            // 0x0090(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetJointTransform) == 0x000010, "Wrong alignment on FRigUnit_GetJointTransform");
static_assert(sizeof(FRigUnit_GetJointTransform) == 0x0000C0, "Wrong size on FRigUnit_GetJointTransform");
static_assert(offsetof(FRigUnit_GetJointTransform, HierarchyRef) == 0x000020, "Member 'FRigUnit_GetJointTransform::HierarchyRef' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetJointTransform, Joint) == 0x000038, "Member 'FRigUnit_GetJointTransform::Joint' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetJointTransform, Type) == 0x000040, "Member 'FRigUnit_GetJointTransform::Type' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetJointTransform, TransformSpace) == 0x000041, "Member 'FRigUnit_GetJointTransform::TransformSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetJointTransform, BaseTransform) == 0x000050, "Member 'FRigUnit_GetJointTransform::BaseTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetJointTransform, BaseJoint) == 0x000080, "Member 'FRigUnit_GetJointTransform::BaseJoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetJointTransform, Output) == 0x000090, "Member 'FRigUnit_GetJointTransform::Output' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_QuaternionToAngle
// 0x0030 (0x0050 - 0x0020)
struct FRigUnit_QuaternionToAngle final : public FRigUnit
{
public:
	struct FVector                                Axis;                                              // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Argument;                                          // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_QuaternionToAngle) == 0x000010, "Wrong alignment on FRigUnit_QuaternionToAngle");
static_assert(sizeof(FRigUnit_QuaternionToAngle) == 0x000050, "Wrong size on FRigUnit_QuaternionToAngle");
static_assert(offsetof(FRigUnit_QuaternionToAngle, Axis) == 0x000020, "Member 'FRigUnit_QuaternionToAngle::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionToAngle, Argument) == 0x000030, "Member 'FRigUnit_QuaternionToAngle::Argument' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionToAngle, Angle) == 0x000040, "Member 'FRigUnit_QuaternionToAngle::Angle' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_QuaternionToAxisAndAngle
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_QuaternionToAxisAndAngle final : public FRigUnit
{
public:
	struct FQuat                                  Argument;                                          // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Axis;                                              // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_QuaternionToAxisAndAngle) == 0x000010, "Wrong alignment on FRigUnit_QuaternionToAxisAndAngle");
static_assert(sizeof(FRigUnit_QuaternionToAxisAndAngle) == 0x000040, "Wrong size on FRigUnit_QuaternionToAxisAndAngle");
static_assert(offsetof(FRigUnit_QuaternionToAxisAndAngle, Argument) == 0x000020, "Member 'FRigUnit_QuaternionToAxisAndAngle::Argument' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionToAxisAndAngle, Axis) == 0x000030, "Member 'FRigUnit_QuaternionToAxisAndAngle::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionToAxisAndAngle, Angle) == 0x00003C, "Member 'FRigUnit_QuaternionToAxisAndAngle::Angle' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MultiplyQuaternion
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_MultiplyQuaternion final : public FRigUnit_BinaryQuaternionOp
{
};
static_assert(alignof(FRigUnit_MultiplyQuaternion) == 0x000010, "Wrong alignment on FRigUnit_MultiplyQuaternion");
static_assert(sizeof(FRigUnit_MultiplyQuaternion) == 0x000050, "Wrong size on FRigUnit_MultiplyQuaternion");

// ScriptStruct ControlRig.RigUnit_Divide_VectorVector
// 0x0000 (0x0048 - 0x0048)
struct FRigUnit_Divide_VectorVector final : public FRigUnit_BinaryVectorOp
{
};
static_assert(alignof(FRigUnit_Divide_VectorVector) == 0x000008, "Wrong alignment on FRigUnit_Divide_VectorVector");
static_assert(sizeof(FRigUnit_Divide_VectorVector) == 0x000048, "Wrong size on FRigUnit_Divide_VectorVector");

// ScriptStruct ControlRig.RigUnit_GetRelativeTransform
// 0x0000 (0x00B0 - 0x00B0)
struct FRigUnit_GetRelativeTransform final : public FRigUnit_BinaryTransformOp
{
};
static_assert(alignof(FRigUnit_GetRelativeTransform) == 0x000010, "Wrong alignment on FRigUnit_GetRelativeTransform");
static_assert(sizeof(FRigUnit_GetRelativeTransform) == 0x0000B0, "Wrong size on FRigUnit_GetRelativeTransform");

// ScriptStruct ControlRig.RigUnit_TransformConstraint
// 0x00E0 (0x0100 - 0x0020)
struct FRigUnit_TransformConstraint final : public FRigUnit
{
public:
	struct FRigHierarchyRef                       HierarchyRef;                                      // 0x0020(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   Joint;                                             // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformSpaceMode                           BaseTransformSpace;                                // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BaseTransform;                                     // 0x0050(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   BaseJoint;                                         // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FConstraintTarget>              Targets;                                           // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x68];                                      // 0x0098(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_TransformConstraint) == 0x000010, "Wrong alignment on FRigUnit_TransformConstraint");
static_assert(sizeof(FRigUnit_TransformConstraint) == 0x000100, "Wrong size on FRigUnit_TransformConstraint");
static_assert(offsetof(FRigUnit_TransformConstraint, HierarchyRef) == 0x000020, "Member 'FRigUnit_TransformConstraint::HierarchyRef' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraint, Joint) == 0x000038, "Member 'FRigUnit_TransformConstraint::Joint' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraint, BaseTransformSpace) == 0x000040, "Member 'FRigUnit_TransformConstraint::BaseTransformSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraint, BaseTransform) == 0x000050, "Member 'FRigUnit_TransformConstraint::BaseTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraint, BaseJoint) == 0x000080, "Member 'FRigUnit_TransformConstraint::BaseJoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraint, Targets) == 0x000088, "Member 'FRigUnit_TransformConstraint::Targets' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TwoBoneIKFK
// 0x01D0 (0x01F0 - 0x0020)
struct FRigUnit_TwoBoneIKFK final : public FRigUnit
{
public:
	struct FRigHierarchyRef                       HierarchyRef;                                      // 0x0020(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   StartJoint;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndJoint;                                          // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePoleTarget;                                    // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PoleTarget;                                        // 0x004C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spin;                                              // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             EndEffector;                                       // 0x0060(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         IKBlend;                                           // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0xC];                                       // 0x0094(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartJointFKTransform;                             // 0x00A0(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             MidJointFKTransform;                               // 0x00D0(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             EndJointFKTransform;                               // 0x0100(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0xC0];                                     // 0x0130(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_TwoBoneIKFK) == 0x000010, "Wrong alignment on FRigUnit_TwoBoneIKFK");
static_assert(sizeof(FRigUnit_TwoBoneIKFK) == 0x0001F0, "Wrong size on FRigUnit_TwoBoneIKFK");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, HierarchyRef) == 0x000020, "Member 'FRigUnit_TwoBoneIKFK::HierarchyRef' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, StartJoint) == 0x000038, "Member 'FRigUnit_TwoBoneIKFK::StartJoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, EndJoint) == 0x000040, "Member 'FRigUnit_TwoBoneIKFK::EndJoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, bUsePoleTarget) == 0x000048, "Member 'FRigUnit_TwoBoneIKFK::bUsePoleTarget' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, PoleTarget) == 0x00004C, "Member 'FRigUnit_TwoBoneIKFK::PoleTarget' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, Spin) == 0x000058, "Member 'FRigUnit_TwoBoneIKFK::Spin' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, EndEffector) == 0x000060, "Member 'FRigUnit_TwoBoneIKFK::EndEffector' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, IKBlend) == 0x000090, "Member 'FRigUnit_TwoBoneIKFK::IKBlend' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, StartJointFKTransform) == 0x0000A0, "Member 'FRigUnit_TwoBoneIKFK::StartJointFKTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, MidJointFKTransform) == 0x0000D0, "Member 'FRigUnit_TwoBoneIKFK::MidJointFKTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, EndJointFKTransform) == 0x000100, "Member 'FRigUnit_TwoBoneIKFK::EndJointFKTransform' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Multiply_VectorVector
// 0x0000 (0x0048 - 0x0048)
struct FRigUnit_Multiply_VectorVector final : public FRigUnit_BinaryVectorOp
{
};
static_assert(alignof(FRigUnit_Multiply_VectorVector) == 0x000008, "Wrong alignment on FRigUnit_Multiply_VectorVector");
static_assert(sizeof(FRigUnit_Multiply_VectorVector) == 0x000048, "Wrong size on FRigUnit_Multiply_VectorVector");

}

